#' @title FCM.new
#' @name FCM.new
#' @description
#' An improved version of FCM for water spectra data sets.
#'
#' @usage FCM.new(FDlist, K, plot.jitter=TRUE, fast.mode=FALSE, stand=FALSE)
#'
#' @param FDlist A \code{list} from function \code{\link{FuzzifierDetermination}}
#' @param K Number, cluster number
#' @param plot.jitter Logical, choose to plot jitter plot using \code{ggplot2} functions
#' @param fast.mode Logical, \code{FALSE} (default)
#' @param stand Logical, choose to do normalization of input data
#'
#' @return A \code{list} of FCM:
#'   \itemize{
#'     \item \strong{FD} The return list by function \code{\link{FuzzifierDetermination}}
#'     \item \strong{res.FCM} The optimized FCM result generated by functions in package \code{ppclust}
#'     \item \strong{K} Cluster number
#'     \item \strong{plot.jitter} A logical value for the option of doing jitter plot by package \code{ggplot2}
#'     \item \strong{fast.mode} A logical value for choosing whether to use fast mode
#'   }
#'
#' @export
#' @examples 
#' \dontrun{
#' library(FCMm)
#' library(tidyverse)
#' data("Nechad2015")
#' w <- Nechad2015 %>% names %>%
#'     str_extract(.,pattern="\\d") %>%
#'     is.na %>% {!.}
#' wv <- w %>% names(Nechad2015)[.] %>%
#'     gsub('X','',.) %>% as.numeric
#' x <- w %>% Nechad2015[,.]
#' names(x) <- wv
#' rm(w)
#' FD <- FuzzifierDetermination(x, wv, stand=F)
#' nb <- 4
#' set.seed(54321)
#' result <- FCM.new(FD, nb)
#' print(result$p.jitter)
#' }
#' 
#' @references 
#' \itemize{
#'   \item Bi S, Li Y, Xu J, et al. Optical classification of inland waters based on
#'     an improved Fuzzy C-Means method[J]. Optics Express, 2019, 27(24): 34838-34856.
#'   \item Dembele D. Multi-objective optimization for clustering 3-way gene
#'     expression data[J]. Advances in Data Analysis and Classification, 2008, 2(3):
#'     211-225.
#' }
#' 


FCM.new <- function(FDlist, K, plot.jitter=TRUE, fast.mode=FALSE,stand=FALSE){
  # K is the cluster number
  if(missing(FDlist)){
    warning("Have your run the function `FuzzifierDetermination` sucessfully?")
    stop("Missing FDlist!")
  }
  if(missing(K))
    stop("Missing cluster number K!")
  if(is.null(K))
    stop("Cluster number K is null")
  if(!is.numeric(K))
    stop("Cluster number must be a numeric value!")

  if(stand==FALSE){
    x <- FDlist$x.stand
  }else if(stand==TRUE){
    x <- FDlist$x
  }

  v <- kmpp(x, k=K)$v
  u <- imembrand(nrow(x), k=K)$u

  if(fast.mode==FALSE){
    res <- fcm(x, centers=v, memberships=u, m=FDlist$m.used, stand=F)
  }else if(fast.mode==TRUE){
    res <- fcm(x, centers=v, memberships=u, m=FDlist$m.used, stand=F,con.val=1e-4)
    message("The fast mode is used. Pay attention to the convergence of the obj. fun. and results!")
  }
  res$u <- .cal.new.membership(res)

  p.jitter <- NULL
  if(plot.jitter)
    p.jitter <- .plot.jitter(res)

  result = list()
  result$FD <- FDlist
  result$res.FCM <- res
  result$p.jitter <- p.jitter
  result$K <- K
  result$plot.jitter <- plot.jitter
  result$fast.mode <- fast.mode

  return(result)
}

#' @export
.cal.new.membership <- function(res){
  if(!is.ppclust(res))
    stop("The input value is not a ppclust list!")
  return(1/res$d^(2/(res$m-1))/(apply(1/res$d^(2/(res$m-1)),1,sum)))
}

#' @export
.plot.jitter <- function(res){
  # mem        numeric matrix
  # SampleID   character matrix
  # m          float value
  # k          int value
  if(!is.ppclust(res))
    stop("The input value is not a ppclust list!")
  mem <- res$u
  m   <- res$m
  k   <- res$k
  SampleID <- rownames(mem)
  name<- res$algorithm
  tmp <- data.frame(mem)
  tmp <- cbind(SampleID,tmp)
  names(tmp)=c("SampleID",as.character(seq(from=1,to=k)))
  tmp.n <- tmp[,-1]
  ind<-sort(apply(tmp[,-1],2,sum),decreasing = T,index.return=T)$ix
  tmp.n2 <- tmp.n[,ind]
  tmp <- cbind(tmp$SampleID,tmp.n2)
  tmp.p <- melt(tmp,id.vars=1)

  p <- ggplot(data=tmp.p) +
    geom_jitter(aes(x=variable,y=value),alpha=I(1/10)) +
    ylim(c(0,1)) +
    theme(plot.title=element_text(hjust=0.5)) +
    labs(title=paste0(name," m=",as.character(m)),x="Cluster",y="Membership degree")
  return(p)
}
